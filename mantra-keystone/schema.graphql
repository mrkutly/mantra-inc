# This file is automatically generated by Keystone, do not modify it manually.
# Modify your Keystone config when you want to change this.

type User {
  id: ID!
  name: String
  email: String
  password: PasswordState
}

type PasswordState {
  isSet: Boolean!
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
  id: IDFilter
  name: StringFilter
  email: StringFilter
}

input IDFilter {
  equals: ID
  in: [ID!]
  notIn: [ID!]
  lt: ID
  lte: ID
  gt: ID
  gte: ID
  not: IDFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  mode: QueryMode
  not: NestedStringFilter
}

enum QueryMode {
  default
  insensitive
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input UserOrderByInput {
  id: OrderDirection
  name: OrderDirection
  email: OrderDirection
}

enum OrderDirection {
  asc
  desc
}

input UserUpdateInput {
  name: String
  email: String
  password: String
}

input UserUpdateArgs {
  where: UserWhereUniqueInput!
  data: UserUpdateInput!
}

input UserCreateInput {
  name: String
  email: String
  password: String
}

type Album {
  id: ID!
  createdAt: DateTime
  group: String
  title: String
  host: String
  embed: String
  link: String
}

scalar DateTime
  @specifiedBy(url: "https://datatracker.ietf.org/doc/html/rfc3339#section-5.6")

input AlbumWhereUniqueInput {
  id: ID
}

input AlbumWhereInput {
  AND: [AlbumWhereInput!]
  OR: [AlbumWhereInput!]
  NOT: [AlbumWhereInput!]
  id: IDFilter
  createdAt: DateTimeNullableFilter
  group: StringFilter
  title: StringFilter
  host: StringFilter
  embed: StringFilter
  link: StringFilter
}

input DateTimeNullableFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: DateTimeNullableFilter
}

input AlbumOrderByInput {
  id: OrderDirection
  createdAt: OrderDirection
  group: OrderDirection
  title: OrderDirection
  host: OrderDirection
  embed: OrderDirection
  link: OrderDirection
}

input AlbumUpdateInput {
  createdAt: DateTime
  group: String
  title: String
  host: String
  embed: String
  link: String
}

input AlbumUpdateArgs {
  where: AlbumWhereUniqueInput!
  data: AlbumUpdateInput!
}

input AlbumCreateInput {
  createdAt: DateTime
  group: String
  title: String
  host: String
  embed: String
  link: String
}

type Article {
  id: ID!
  createdAt: DateTime
  group: String
  title: String
  publication: String
  pullQuote: String
  author: String
  link: String
}

input ArticleWhereUniqueInput {
  id: ID
}

input ArticleWhereInput {
  AND: [ArticleWhereInput!]
  OR: [ArticleWhereInput!]
  NOT: [ArticleWhereInput!]
  id: IDFilter
  createdAt: DateTimeNullableFilter
  group: StringFilter
  title: StringFilter
  publication: StringFilter
  pullQuote: StringFilter
  author: StringFilter
  link: StringFilter
}

input ArticleOrderByInput {
  id: OrderDirection
  createdAt: OrderDirection
  group: OrderDirection
  title: OrderDirection
  publication: OrderDirection
  pullQuote: OrderDirection
  author: OrderDirection
  link: OrderDirection
}

input ArticleUpdateInput {
  createdAt: DateTime
  group: String
  title: String
  publication: String
  pullQuote: String
  author: String
  link: String
}

input ArticleUpdateArgs {
  where: ArticleWhereUniqueInput!
  data: ArticleUpdateInput!
}

input ArticleCreateInput {
  createdAt: DateTime
  group: String
  title: String
  publication: String
  pullQuote: String
  author: String
  link: String
}

type Video {
  id: ID!
  createdAt: DateTime
  group: String
  title: String
  embed: String
}

input VideoWhereUniqueInput {
  id: ID
}

input VideoWhereInput {
  AND: [VideoWhereInput!]
  OR: [VideoWhereInput!]
  NOT: [VideoWhereInput!]
  id: IDFilter
  createdAt: DateTimeNullableFilter
  group: StringFilter
  title: StringFilter
  embed: StringFilter
}

input VideoOrderByInput {
  id: OrderDirection
  createdAt: OrderDirection
  group: OrderDirection
  title: OrderDirection
  embed: OrderDirection
}

input VideoUpdateInput {
  createdAt: DateTime
  group: String
  title: String
  embed: String
}

input VideoUpdateArgs {
  where: VideoWhereUniqueInput!
  data: VideoUpdateInput!
}

input VideoCreateInput {
  createdAt: DateTime
  group: String
  title: String
  embed: String
}

type Team {
  id: ID!
  createdAt: DateTime
  title: String
  members(
    where: TeamMemberWhereInput! = {}
    orderBy: [TeamMemberOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TeamMember!]
  membersCount(where: TeamMemberWhereInput! = {}): Int
}

input TeamWhereUniqueInput {
  id: ID
}

input TeamWhereInput {
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
  id: IDFilter
  createdAt: DateTimeNullableFilter
  title: StringFilter
  members: TeamMemberManyRelationFilter
}

input TeamMemberManyRelationFilter {
  every: TeamMemberWhereInput
  some: TeamMemberWhereInput
  none: TeamMemberWhereInput
}

input TeamOrderByInput {
  id: OrderDirection
  createdAt: OrderDirection
  title: OrderDirection
}

input TeamUpdateInput {
  createdAt: DateTime
  title: String
  members: TeamMemberRelateToManyForUpdateInput
}

input TeamMemberRelateToManyForUpdateInput {
  disconnect: [TeamMemberWhereUniqueInput!]
  set: [TeamMemberWhereUniqueInput!]
  create: [TeamMemberCreateInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

input TeamUpdateArgs {
  where: TeamWhereUniqueInput!
  data: TeamUpdateInput!
}

input TeamCreateInput {
  createdAt: DateTime
  title: String
  members: TeamMemberRelateToManyForCreateInput
}

input TeamMemberRelateToManyForCreateInput {
  create: [TeamMemberCreateInput!]
  connect: [TeamMemberWhereUniqueInput!]
}

type TeamMember {
  id: ID!
  name: String
  team: Team
  roles(
    where: TeamMemberRoleWhereInput! = {}
    orderBy: [TeamMemberRoleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TeamMemberRole!]
  rolesCount(where: TeamMemberRoleWhereInput! = {}): Int
}

input TeamMemberWhereUniqueInput {
  id: ID
}

input TeamMemberWhereInput {
  AND: [TeamMemberWhereInput!]
  OR: [TeamMemberWhereInput!]
  NOT: [TeamMemberWhereInput!]
  id: IDFilter
  name: StringFilter
  team: TeamWhereInput
  roles: TeamMemberRoleManyRelationFilter
}

input TeamMemberRoleManyRelationFilter {
  every: TeamMemberRoleWhereInput
  some: TeamMemberRoleWhereInput
  none: TeamMemberRoleWhereInput
}

input TeamMemberOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input TeamMemberUpdateInput {
  name: String
  team: TeamRelateToOneForUpdateInput
  roles: TeamMemberRoleRelateToManyForUpdateInput
}

input TeamRelateToOneForUpdateInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
  disconnect: Boolean
}

input TeamMemberRoleRelateToManyForUpdateInput {
  disconnect: [TeamMemberRoleWhereUniqueInput!]
  set: [TeamMemberRoleWhereUniqueInput!]
  create: [TeamMemberRoleCreateInput!]
  connect: [TeamMemberRoleWhereUniqueInput!]
}

input TeamMemberUpdateArgs {
  where: TeamMemberWhereUniqueInput!
  data: TeamMemberUpdateInput!
}

input TeamMemberCreateInput {
  name: String
  team: TeamRelateToOneForCreateInput
  roles: TeamMemberRoleRelateToManyForCreateInput
}

input TeamRelateToOneForCreateInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

input TeamMemberRoleRelateToManyForCreateInput {
  create: [TeamMemberRoleCreateInput!]
  connect: [TeamMemberRoleWhereUniqueInput!]
}

type TeamMemberRole {
  id: ID!
  title: String
}

input TeamMemberRoleWhereUniqueInput {
  id: ID
}

input TeamMemberRoleWhereInput {
  AND: [TeamMemberRoleWhereInput!]
  OR: [TeamMemberRoleWhereInput!]
  NOT: [TeamMemberRoleWhereInput!]
  id: IDFilter
  title: StringFilter
}

input TeamMemberRoleOrderByInput {
  id: OrderDirection
  title: OrderDirection
}

input TeamMemberRoleUpdateInput {
  title: String
}

input TeamMemberRoleUpdateArgs {
  where: TeamMemberRoleWhereUniqueInput!
  data: TeamMemberRoleUpdateInput!
}

input TeamMemberRoleCreateInput {
  title: String
}

type Concert {
  id: ID!
  createdAt: DateTime
  dateFrom: DateTime
  dateTo: DateTime
  group: String
  location: Location
  program(
    where: PieceWhereInput! = {}
    orderBy: [PieceOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Piece!]
  programCount(where: PieceWhereInput! = {}): Int
}

input ConcertWhereUniqueInput {
  id: ID
}

input ConcertWhereInput {
  AND: [ConcertWhereInput!]
  OR: [ConcertWhereInput!]
  NOT: [ConcertWhereInput!]
  id: IDFilter
  createdAt: DateTimeNullableFilter
  dateFrom: DateTimeNullableFilter
  dateTo: DateTimeNullableFilter
  group: StringFilter
  location: LocationWhereInput
  program: PieceManyRelationFilter
}

input PieceManyRelationFilter {
  every: PieceWhereInput
  some: PieceWhereInput
  none: PieceWhereInput
}

input ConcertOrderByInput {
  id: OrderDirection
  createdAt: OrderDirection
  dateFrom: OrderDirection
  dateTo: OrderDirection
  group: OrderDirection
}

input ConcertUpdateInput {
  createdAt: DateTime
  dateFrom: DateTime
  dateTo: DateTime
  group: String
  location: LocationRelateToOneForUpdateInput
  program: PieceRelateToManyForUpdateInput
}

input LocationRelateToOneForUpdateInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
  disconnect: Boolean
}

input PieceRelateToManyForUpdateInput {
  disconnect: [PieceWhereUniqueInput!]
  set: [PieceWhereUniqueInput!]
  create: [PieceCreateInput!]
  connect: [PieceWhereUniqueInput!]
}

input ConcertUpdateArgs {
  where: ConcertWhereUniqueInput!
  data: ConcertUpdateInput!
}

input ConcertCreateInput {
  createdAt: DateTime
  dateFrom: DateTime
  dateTo: DateTime
  group: String
  location: LocationRelateToOneForCreateInput
  program: PieceRelateToManyForCreateInput
}

input LocationRelateToOneForCreateInput {
  create: LocationCreateInput
  connect: LocationWhereUniqueInput
}

input PieceRelateToManyForCreateInput {
  create: [PieceCreateInput!]
  connect: [PieceWhereUniqueInput!]
}

type Piece {
  id: ID!
  composer: String
  title: String
  description: String
  support: String
}

input PieceWhereUniqueInput {
  id: ID
}

input PieceWhereInput {
  AND: [PieceWhereInput!]
  OR: [PieceWhereInput!]
  NOT: [PieceWhereInput!]
  id: IDFilter
  composer: StringFilter
  title: StringFilter
  description: StringFilter
  support: StringFilter
}

input PieceOrderByInput {
  id: OrderDirection
  composer: OrderDirection
  title: OrderDirection
  description: OrderDirection
  support: OrderDirection
}

input PieceUpdateInput {
  composer: String
  title: String
  description: String
  support: String
}

input PieceUpdateArgs {
  where: PieceWhereUniqueInput!
  data: PieceUpdateInput!
}

input PieceCreateInput {
  composer: String
  title: String
  description: String
  support: String
}

type Location {
  id: ID!
  venue: String
  city: String
  support: String
}

input LocationWhereUniqueInput {
  id: ID
}

input LocationWhereInput {
  AND: [LocationWhereInput!]
  OR: [LocationWhereInput!]
  NOT: [LocationWhereInput!]
  id: IDFilter
  venue: StringFilter
  city: StringFilter
  support: StringFilter
}

input LocationOrderByInput {
  id: OrderDirection
  venue: OrderDirection
  city: OrderDirection
  support: OrderDirection
}

input LocationUpdateInput {
  venue: String
  city: String
  support: String
}

input LocationUpdateArgs {
  where: LocationWhereUniqueInput!
  data: LocationUpdateInput!
}

input LocationCreateInput {
  venue: String
  city: String
  support: String
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON
  @specifiedBy(
    url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf"
  )

type Mutation {
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  updateUser(where: UserWhereUniqueInput!, data: UserUpdateInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  createAlbum(data: AlbumCreateInput!): Album
  createAlbums(data: [AlbumCreateInput!]!): [Album]
  updateAlbum(where: AlbumWhereUniqueInput!, data: AlbumUpdateInput!): Album
  updateAlbums(data: [AlbumUpdateArgs!]!): [Album]
  deleteAlbum(where: AlbumWhereUniqueInput!): Album
  deleteAlbums(where: [AlbumWhereUniqueInput!]!): [Album]
  createArticle(data: ArticleCreateInput!): Article
  createArticles(data: [ArticleCreateInput!]!): [Article]
  updateArticle(
    where: ArticleWhereUniqueInput!
    data: ArticleUpdateInput!
  ): Article
  updateArticles(data: [ArticleUpdateArgs!]!): [Article]
  deleteArticle(where: ArticleWhereUniqueInput!): Article
  deleteArticles(where: [ArticleWhereUniqueInput!]!): [Article]
  createVideo(data: VideoCreateInput!): Video
  createVideos(data: [VideoCreateInput!]!): [Video]
  updateVideo(where: VideoWhereUniqueInput!, data: VideoUpdateInput!): Video
  updateVideos(data: [VideoUpdateArgs!]!): [Video]
  deleteVideo(where: VideoWhereUniqueInput!): Video
  deleteVideos(where: [VideoWhereUniqueInput!]!): [Video]
  createTeam(data: TeamCreateInput!): Team
  createTeams(data: [TeamCreateInput!]!): [Team]
  updateTeam(where: TeamWhereUniqueInput!, data: TeamUpdateInput!): Team
  updateTeams(data: [TeamUpdateArgs!]!): [Team]
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteTeams(where: [TeamWhereUniqueInput!]!): [Team]
  createTeamMember(data: TeamMemberCreateInput!): TeamMember
  createTeamMembers(data: [TeamMemberCreateInput!]!): [TeamMember]
  updateTeamMember(
    where: TeamMemberWhereUniqueInput!
    data: TeamMemberUpdateInput!
  ): TeamMember
  updateTeamMembers(data: [TeamMemberUpdateArgs!]!): [TeamMember]
  deleteTeamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  deleteTeamMembers(where: [TeamMemberWhereUniqueInput!]!): [TeamMember]
  createTeamMemberRole(data: TeamMemberRoleCreateInput!): TeamMemberRole
  createTeamMemberRoles(data: [TeamMemberRoleCreateInput!]!): [TeamMemberRole]
  updateTeamMemberRole(
    where: TeamMemberRoleWhereUniqueInput!
    data: TeamMemberRoleUpdateInput!
  ): TeamMemberRole
  updateTeamMemberRoles(data: [TeamMemberRoleUpdateArgs!]!): [TeamMemberRole]
  deleteTeamMemberRole(where: TeamMemberRoleWhereUniqueInput!): TeamMemberRole
  deleteTeamMemberRoles(
    where: [TeamMemberRoleWhereUniqueInput!]!
  ): [TeamMemberRole]
  createConcert(data: ConcertCreateInput!): Concert
  createConcerts(data: [ConcertCreateInput!]!): [Concert]
  updateConcert(
    where: ConcertWhereUniqueInput!
    data: ConcertUpdateInput!
  ): Concert
  updateConcerts(data: [ConcertUpdateArgs!]!): [Concert]
  deleteConcert(where: ConcertWhereUniqueInput!): Concert
  deleteConcerts(where: [ConcertWhereUniqueInput!]!): [Concert]
  createPiece(data: PieceCreateInput!): Piece
  createPieces(data: [PieceCreateInput!]!): [Piece]
  updatePiece(where: PieceWhereUniqueInput!, data: PieceUpdateInput!): Piece
  updatePieces(data: [PieceUpdateArgs!]!): [Piece]
  deletePiece(where: PieceWhereUniqueInput!): Piece
  deletePieces(where: [PieceWhereUniqueInput!]!): [Piece]
  createLocation(data: LocationCreateInput!): Location
  createLocations(data: [LocationCreateInput!]!): [Location]
  updateLocation(
    where: LocationWhereUniqueInput!
    data: LocationUpdateInput!
  ): Location
  updateLocations(data: [LocationUpdateArgs!]!): [Location]
  deleteLocation(where: LocationWhereUniqueInput!): Location
  deleteLocations(where: [LocationWhereUniqueInput!]!): [Location]
  endSession: Boolean!
  authenticateUserWithPassword(
    email: String!
    password: String!
  ): UserAuthenticationWithPasswordResult
  createInitialUser(
    data: CreateInitialUserInput!
  ): UserAuthenticationWithPasswordSuccess!
}

union UserAuthenticationWithPasswordResult =
    UserAuthenticationWithPasswordSuccess
  | UserAuthenticationWithPasswordFailure

type UserAuthenticationWithPasswordSuccess {
  sessionToken: String!
  item: User!
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

input CreateInitialUserInput {
  name: String
  email: String
  password: String
}

type Query {
  users(
    where: UserWhereInput! = {}
    orderBy: [UserOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [User!]
  user(where: UserWhereUniqueInput!): User
  usersCount(where: UserWhereInput! = {}): Int
  albums(
    where: AlbumWhereInput! = {}
    orderBy: [AlbumOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Album!]
  album(where: AlbumWhereUniqueInput!): Album
  albumsCount(where: AlbumWhereInput! = {}): Int
  articles(
    where: ArticleWhereInput! = {}
    orderBy: [ArticleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Article!]
  article(where: ArticleWhereUniqueInput!): Article
  articlesCount(where: ArticleWhereInput! = {}): Int
  videos(
    where: VideoWhereInput! = {}
    orderBy: [VideoOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Video!]
  video(where: VideoWhereUniqueInput!): Video
  videosCount(where: VideoWhereInput! = {}): Int
  teams(
    where: TeamWhereInput! = {}
    orderBy: [TeamOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Team!]
  team(where: TeamWhereUniqueInput!): Team
  teamsCount(where: TeamWhereInput! = {}): Int
  teamMembers(
    where: TeamMemberWhereInput! = {}
    orderBy: [TeamMemberOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TeamMember!]
  teamMember(where: TeamMemberWhereUniqueInput!): TeamMember
  teamMembersCount(where: TeamMemberWhereInput! = {}): Int
  teamMemberRoles(
    where: TeamMemberRoleWhereInput! = {}
    orderBy: [TeamMemberRoleOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [TeamMemberRole!]
  teamMemberRole(where: TeamMemberRoleWhereUniqueInput!): TeamMemberRole
  teamMemberRolesCount(where: TeamMemberRoleWhereInput! = {}): Int
  concerts(
    where: ConcertWhereInput! = {}
    orderBy: [ConcertOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Concert!]
  concert(where: ConcertWhereUniqueInput!): Concert
  concertsCount(where: ConcertWhereInput! = {}): Int
  pieces(
    where: PieceWhereInput! = {}
    orderBy: [PieceOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Piece!]
  piece(where: PieceWhereUniqueInput!): Piece
  piecesCount(where: PieceWhereInput! = {}): Int
  locations(
    where: LocationWhereInput! = {}
    orderBy: [LocationOrderByInput!]! = []
    take: Int
    skip: Int! = 0
  ): [Location!]
  location(where: LocationWhereUniqueInput!): Location
  locationsCount(where: LocationWhereInput! = {}): Int
  keystone: KeystoneMeta!
  authenticatedItem: AuthenticatedItem
}

union AuthenticatedItem = User

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type KeystoneAdminMeta {
  enableSignout: Boolean!
  enableSessionItem: Boolean!
  lists: [KeystoneAdminUIListMeta!]!
  list(key: String!): KeystoneAdminUIListMeta
}

type KeystoneAdminUIListMeta {
  key: String!
  itemQueryName: String!
  listQueryName: String!
  hideCreate: Boolean!
  hideDelete: Boolean!
  path: String!
  label: String!
  singular: String!
  plural: String!
  description: String
  initialColumns: [String!]!
  pageSize: Int!
  labelField: String!
  fields: [KeystoneAdminUIFieldMeta!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
}

type KeystoneAdminUIFieldMeta {
  path: String!
  label: String!
  isOrderable: Boolean!
  isFilterable: Boolean!
  fieldMeta: JSON
  viewsIndex: Int!
  customViewsIndex: Int
  createView: KeystoneAdminUIFieldMetaCreateView!
  listView: KeystoneAdminUIFieldMetaListView!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  search: QueryMode
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  read
  hidden
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  read
  hidden
}

type KeystoneAdminUISort {
  field: String!
  direction: KeystoneAdminUISortDirection!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}
